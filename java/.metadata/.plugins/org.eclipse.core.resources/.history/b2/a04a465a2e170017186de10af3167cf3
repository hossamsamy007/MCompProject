package uk.ac.ncl.burton.twy.ZPK2;

import static org.junit.Assert.*;

import java.math.BigInteger;
import java.security.SecureRandom;

import org.junit.Test;

import uk.ac.ncl.burton.twy.maths.CyclicGroup;
import uk.ac.ncl.burton.twy.utils.BigIntegerUtils;

public class PoKTesting {

	@Test
	public void PoKTesting() {
		SecureRandom ran = new SecureRandom();
		
		CyclicGroup G = CyclicGroup.generateGroup(256);
		BigInteger g = G.getG();
		
		BigInteger a = BigInteger.TEN; // BigIntegerUtils.randomBetween(BigInteger.ONE, G.getQ(), ran);
		BigInteger b = BigInteger.TEN; // BigIntegerUtils.randomBetween(BigInteger.ONE, G.getQ(), ran);
		
		BigInteger mod = G.getQ();
		
		
		// === STEP 1 ===
		
		// -- Calculations --
		BigInteger h =  G.generateGenerator();
		BigInteger x1 = RandomZQ(g,G.getQ(),ran);//BigIntegerUtils.randomBetween(BigInteger.ONE, G.getQ(), ran); 
		BigInteger x2 = RandomZQ(g,G.getQ(),ran);//BigIntegerUtils.randomBetween(BigInteger.ONE, G.getQ(), ran);
		BigInteger r =  RandomZQ(g,G.getQ(),ran);//BigIntegerUtils.randomBetween(BigInteger.ONE, G.getQ(), ran);
		
		BigInteger c =  g.modPow( x1, mod ).multiply( h.modPow( x2, mod));
		BigInteger u1 = g.modPow(r, mod );
		BigInteger u2 = h.modPow(r, mod );
		BigInteger e =  g.modPow( a, mod ).multiply( c.modPow( r, mod));
		
		// -- PoK --
		
		PoKProver peggy = new PoKProver(G);
		PoKVerifier victor = new PoKVerifier(G);
		
		
		
		
		
		
		
	}



	private BigInteger RandomZQ(BigInteger g, BigInteger q, SecureRandom ran){
		return BigIntegerUtils.randomBetween(BigInteger.ONE, q, ran);
	}

}
