package uk.ac.ncl.burton.twy.ZPK2;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;

import uk.ac.ncl.burton.twy.maths.CyclicGroup;
import uk.ac.ncl.burton.twy.utils.BigIntegerUtils;

public class PoKProver {

	/**
	 * The cyclic group for the proof
	 */
	private CyclicGroup G;
	
	private List<BigInteger> bases;
	private List<BigInteger> exponents;
	private List<BigInteger> randomExponents;
	
	private BigInteger value;


	private PoKProver( CyclicGroup G, List<BigInteger> bases, List<BigInteger> exponents ){
		
		if( bases.size() != exponents.size()){
			throw new IllegalArgumentException("The number of bases must match the number of exponents");
		}
		
		this.bases = bases;
		this.exponents = exponents;
		this.G = G;
		
		BigInteger x = BigInteger.ONE;
		for(int i = 0 ; i < bases.size(); i++ ){
			x = x.multiply( bases.get(i).modPow(exponents.get(i), G.getQ())).mod(G.getQ());
		}
		
		this.value = x;
		
		generateRandomValues();
	}

	
	
	public static PoKProver generateProver( CyclicGroup G, List<BigInteger> bases, List<BigInteger> exponents){
		return new PoKProver(G,bases,exponents);
	}
	
	public static PoKProver generateProver( CyclicGroup G, BigInteger base, BigInteger exponent){
		
		List<BigInteger> bases = new ArrayList<BigInteger>();
		List<BigInteger> exponents = new ArrayList<BigInteger>();
		
		bases.add(base);
		exponents.add(exponent);
		
		return new PoKProver(G,bases,exponents);
		
	}

	public BigInteger getValue(){
		return value;
	}
	
	
	private void generateRandomValues(){
		randomExponents = new ArrayList<BigInteger>();
		for( int i = 0 ; i < exponents.size(); i++ ) randomExponents.add(BigIntegerUtils.randomBetween( BigInteger.ONE, G.getQ() ));
	}
	
	public BigInteger getCommitment(){
		BigInteger t = BigInteger.ONE;
		for(int i = 0 ; i < bases.size(); i++ ){
			t = t.multiply( bases.get(i).modPow(randomExponents.get(i), G.getQ())).mod(G.getQ());
		}
		return t;
	}
	
	public List<BigInteger> getResponse( BigInteger c ){
		
	}
}
