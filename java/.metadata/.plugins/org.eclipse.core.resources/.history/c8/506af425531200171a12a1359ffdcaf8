package uk.ac.ncl.burton.twy.PSPAKEDH;

import static org.junit.Assert.*;

import java.math.BigInteger;

import org.junit.Test;

import uk.ac.ncl.burton.twy.crypto.Crypto;
import uk.ac.ncl.burton.twy.maths.CyclicGroup;
import uk.ac.ncl.burton.twy.utils.BigIntegerUtils;

public class PSPakePHTesting {

	@Test
	public void test() {
		
		CyclicGroup G = CyclicGroup.generateGroup(512);
		
		BigInteger g = G.getG();
		
		BigInteger a = BigIntegerUtils.randomBetween( BigInteger.ONE, G.getQ() );
		BigInteger b = BigIntegerUtils.randomBetween( BigInteger.ONE, G.getQ() );
		
		BigInteger password = BigInteger.valueOf(123456);
		BigInteger r = BigInteger.valueOf(1234567890);
		
		BigInteger sender = BigInteger.valueOf(1111);
		BigInteger receiver = BigInteger.valueOf(2222);
		
		// STEP 1
		BigInteger idP = Crypto.hash( sender.add(receiver).add(password) ).mod(G.getQ()).modPow(r, G.getQ()) ; // Hashed identity and password
		BigInteger m = g.modPow(a, G.getQ()).multiply( idP ).mod(G.getQ()) ; // g^a · (H1(sender,receiver,password))^r
		
		System.out.println("m: " + m);
		
		// STEP 2
		BigInteger B = g.modPow(b, G.getQ());
		
		BigInteger Or = m.divide( idP.modPow(r, G.getQ()) ).modPow(b, G.getQ());
		
		// STEP 3
		BigInteger Os = B.modPow(a, G.getQ());
		System.out.println("Os: " + Os);
		System.out.println("Or: " + Or);
		
		
		// STANDARD DH.
		/*BigInteger A = g.modPow(a, G.getQ());
		BigInteger B = g.modPow(b, G.getQ());
		
		System.out.println(A.modPow(b, G.getQ()));
		System.out.println(B.modPow(a, G.getQ()));*/
		
		
		
		
	}

}
